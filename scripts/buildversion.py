#!/usr/bin/env python
# Generate version information for a program
#
# Copyright (C) 2015  Kevin O'Connor <kevin@koconnor.net>
#
# This file may be distributed under the terms of the GNU GPLv3 license.
import sys, os, subprocess, time, socket, optparse, re

VERSION_FORMAT = """
/* DO NOT EDIT!  This is an autogenerated file.  See scripts/buildversion.py. */
#define BUILD_VERSION "%s"
#define BUILD_TOOLS "%s"
"""

# Obtain version info from "git" program
def git_version():
    if not os.path.exists('.git'):
        return ""
    params = "git describe --tags --long --dirty".split()
    try:
        ver = subprocess.check_output(params).decode().strip()
    except:
        return ""
    return ver

# Look for version in a ".version" file
def file_version():
    if not os.path.isfile('.version'):
        return ""
    try:
        f = open('.version', 'r')
        ver = f.readline().strip()
        f.close()
    except:
        return ""
    return ver

# Generate an output file with the version information
def write_version(outfile, version, toolstr):
    sys.stdout.write("Version: %s\n" % (version,))
    f = open(outfile, 'w')
    f.write(VERSION_FORMAT % (version, toolstr))
    f.close()

re_gcc = re.compile(r'^(?P<prog>.*) \(GCC\) (?P<version>.*)$')
re_binutils = re.compile(r'^GNU (?P<prog>.*) version (?P<version>.*)$')

# Run "tool --version" for each specified tool and extract versions
def tool_versions(tools):
    tools = [t.strip() for t in tools.split(';')]
    gcc = binutils = ""
    success = 0
    for tool in tools:
        try:
            ver = subprocess.check_output([tool, '--version']).decode()
        except:
            continue
        ver = ver.split('\n')[0]
        m = re_gcc.match(ver)
        if m:
            ver = m.group('version')
            if gcc and gcc != ver:
                gcc = "mixed"
                continue
            gcc = ver
            success += 1
            continue
        m = re_binutils.match(ver)
        if m:
            ver = m.group('version')
            if binutils and binutils != ver:
                binutils = "mixed"
                continue
            binutils = ver
            success += 1
    cleanbuild = binutils and gcc and success == len(tools)
    return cleanbuild, "gcc: %s binutils: %s" % (gcc, binutils)

def main():
    usage = "%prog [options] <outputheader.h>"
    opts = optparse.OptionParser(usage)
    opts.add_option("-e", "--extra", dest="extra", default="",
                    help="extra version string to append to version")
    opts.add_option("-t", "--tools", dest="tools", default="",
                    help="list of build programs to extra version from")

    options, args = opts.parse_args()
    if len(args) != 1:
        opts.error("Incorrect arguments")
    outfile = args[0]

    cleanbuild, toolstr = tool_versions(options.tools)

    ver = git_version()
    cleanbuild = cleanbuild and ver and 'dirty' not in ver
    if not ver:
        ver = file_version()
        if not ver:
            ver = "?"
    if not cleanbuild:
        btime = time.strftime("%Y%m%d_%H%M%S")
        hostname = socket.gethostname()
        ver = "%s-%s-%s" % (ver, btime, hostname)
    write_version(outfile, ver + options.extra, toolstr)

if __name__ == '__main__':
    main()
